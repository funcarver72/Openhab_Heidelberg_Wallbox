// Rule File  OpenHAB V3.xx    for Wallbox

rule "Rule_WB_Init"
when
	System started
   or Item SysInit received command ON
then
	logInfo("Init rule: ", "Rule Init Started")

   // Wallbox Init
   // WB_R261_Set_Max_I.sendCommand(60)      // init to min setting, 60 = 6A
   // Thread::sleep(100)

   // WB_R262_Set_FS_I.sendCommand(60)       // init to min setting, 60 = 6A
   // Thread::sleep(100)

   // WB_R259w_RemoveLock.sendCommand(1)      // init to unlocked
   // Thread::sleep(100)

   // WB_R258w_Standby.sendCommand(4)         // init to  No Standby !!
   // Thread::sleep(100)

   // User Interface Init
   if (vCHG_EnergyTarget_en.state==NULL)  vCHG_EnergyTarget_en.sendCommand(OFF)
   if (vCHG_EnergyLimit.state==NULL)      vCHG_EnergyLimit.sendCommand(50)
   if (vCHG_PowerTarget_en.state==NULL)   vCHG_PowerTarget_en.sendCommand(0)
   if (vCHG_PowerLimit.state==NULL)       vCHG_PowerLimit.sendCommand(6)

   // if (vCHG_StartTime_en.state==NULL)     vCHG_StartTime_en.sendCommand(OFF)
   if (vCHG_StartTime_H.state==NULL)      vCHG_StartTime_H.sendCommand(18)
   if (vCHG_StartTime_M.state==NULL)      vCHG_StartTime_M.sendCommand(0)

   // if (vCHG_StopTime_en.state==NULL)      vCHG_StopTime_en.sendCommand(OFF)
   if (vCHG_StopTime_H.state==NULL)       vCHG_StopTime_H.sendCommand(6)
   if (vCHG_StopTime_M.state==NULL)       vCHG_StopTime_M.sendCommand(0)

   // Initialisieren der Strings
   vCHG_StartTime_en.sendCommand(ON)
   vCHG_StopTime_en.sendCommand(ON)  
   vCHG_StartTime_en.sendCommand(OFF)
   vCHG_StopTime_en.sendCommand(OFF)

   Go_Charge.sendCommand(OFF)
end 


// ------------------------------
// ***   Charging Control     ***
// ------------------------------

//  Formel zur Ermittlung des Max. Ladestroms
//  Ladestrom(neu) = Energieproduktion  -  (HausVerbrauch + Ladestrom(alt) )
//  Dann:  Wenn Ladestrom <= 0 dann Ladestrom = 0

//  Update, alle 5 Minuten (oder besser wenn sich die Zahlen ändern)

// bei 3-phasigem Laden ganz einfach:
//  Laden mit 6A  wenn  der Berechnete Ladestrom >0 ist
// bei 1-phasigem Laden kann man in den Bereich der Regelung kommen.




// rule "Rule_Determine_Phases" 
// when
//    System started
//    or Item WB_R010_V_L1 changed
//    or Item WB_R010_V_L2 changed 
//    or Item WB_R010_V_L3 changed
// then 
//    if ( (WB_R010_V_L1.state < 50) && (WB_R011_V_L2.state < 50) && (WB_R012_V_L3.state < 50) ) {
//       WB_1phase_mode.sendCommand(OFF)
//       WB_3phase_mode.sendCommand(OFF)
//       // send Mail: Wallbox Ausgeschaltet ?
//    } 
//    else if ( (WB_R010_V_L1.state > 215) && (WB_R011_V_L2.state < 50) && (WB_R012_V_L3.state < 50) ) {
//       WB_1phase_mode.sendCommand(ON)
//       WB_3phase_mode.sendCommand(OFF)
//    }
//    else if ( (WB_R010_V_L1.state > 215) && (WB_R011_V_L2.state > 215) && (WB_R012_V_L3.state > 215) ) {
//       WB_1phase_mode.sendCommand(OFF)
//       WB_3phase_mode.sendCommand(ON)
//    } 
//    else {
//       WB_1phase_mode.sendCommand(OFF)
//       WB_3phase_mode.sendCommand(OFF)
//       // send Mail: Wallbox Unbekannter Versorgungszustand
//    } 
// end


rule "Rule_Determine_CHG_Current"
when 
   System started
or Item vCHG_PowerTarget_en received command
or Item vCHG_PowerLimit received command
then 
  if (vCHG_PowerTarget_en.state==0)
   vCHG_Max_I.sendCommand(160)                  // max Current 16A
  else if (vCHG_PowerTarget_en.state==1)  {     // Selected Power
     
     // var int int_PowerLimit = vCHG_PowerLimit.state.intValue 
     
     if (vCHG_PowerLimit.state==2)        vCHG_Max_I.sendCommand(60)     // 29  --> nicht erlaubt.  60   
      else if (vCHG_PowerLimit.state==3)  vCHG_Max_I.sendCommand(60)     //  44 nicht erlaubt. setze 60
      else if (vCHG_PowerLimit.state==4)  vCHG_Max_I.sendCommand(60)   
      else if (vCHG_PowerLimit.state==5)  vCHG_Max_I.sendCommand(73)   
      else if (vCHG_PowerLimit.state==6)  vCHG_Max_I.sendCommand(87)   
      else if (vCHG_PowerLimit.state==7)  vCHG_Max_I.sendCommand(102)   
      else if (vCHG_PowerLimit.state==8)  vCHG_Max_I.sendCommand(116)   
      else if (vCHG_PowerLimit.state==9)  vCHG_Max_I.sendCommand(130)   
      else if (vCHG_PowerLimit.state==10) vCHG_Max_I.sendCommand(145)   
      else logError("Rule_Determine_CHG_Current", "Unknown Selection of PowerLimit")

  }
  else if (vCHG_PowerTarget_en.state==2) {     // PV Überschuss
      vCHG_Max_I.sendCommand(60)     // Minimum für ON
  }
  else logError("Rule_Determine_CHG_Current", "Unknown Selection of PowerTarget_en")

end


// --------------
//  Timers
rule "Rule_CHG_StartTime_Set"
when 
   Item vCHG_StartTime_en received command ON
or Item vCHG_StartTime_H  received update  
or Item vCHG_StartTime_M  received update 
then
 if (vCHG_StartTime_M.state == 0) 
  vCHG_StartTime_S.postUpdate( (vCHG_StartTime_H.state as Number).intValue.toString + ":00"  )
 else
  vCHG_StartTime_S.postUpdate( (vCHG_StartTime_H.state as Number).intValue.toString + ":" + (vCHG_StartTime_M.state as Number).intValue.toString)
end 

rule "Rule_CHG_StopTime_Set"
when 
   Item vCHG_StopTime_en received command ON
or Item vCHG_StopTime_H  received update  
or Item vCHG_StopTime_M  received update 
then
 if (vCHG_StopTime_M.state == 0) 
  vCHG_StopTime_S.postUpdate( (vCHG_StopTime_H.state as Number).intValue.toString + ":00"  )
 else
  vCHG_StopTime_S.postUpdate( (vCHG_StopTime_H.state as Number).intValue.toString + ":" + (vCHG_StopTime_M.state as Number).intValue.toString)
end 


rule "Rule_Format_CHG_Currents"
when
      Item WB_R006_I_L1 received update 
   or Item WB_R007_I_L2 received update
   or Item WB_R008_I_L3 received update
then 
     vWB_Currents_L1L2L3.postUpdate( (WB_R006_I_L1.state as Number).toString + " A / " + (WB_R007_I_L2.state as Number).toString + " A / " + (WB_R008_I_L3.state as Number).toString + " A" )
end


rule "Rule_Format_Supply_Voltages"
when
      Item WB_R010_V_L1 received update 
   or Item WB_R011_V_L2 received update
   or Item WB_R012_V_L3 received update
then 
     vWB_SupplyV_L1L2L3.postUpdate( (WB_R010_V_L1.state as Number).toString + " V / " + (WB_R011_V_L2.state as Number).toString + " V / " + (WB_R012_V_L3.state as Number).toString + " V" )
end


// 1. Start Charging
// Button Start gedrückt
// Lade-Energie auf 0 gesetzt

// Wenn Start=ON und timer=startzeit dann los.
rule "Rule_Start_Charging"
when
   Item Go_Charge received command ON
then 
   // vCHG_EnergyCharged.postUpdate(0.0)                             // Charging Energy Counter 0 setzen
   // vCHG_EnergyStart.postUpdate(WB_R015_Energy_PwrOn)              // Startwert des EnergyCounters sichern

   if (vCHG_StartTime_en.state==OFF)  {
      WB_R261_Set_Max_I.sendCommand(vCHG_Max_I.state as Number)
      logInfo("Rule_Start_Charging: ", "Laden jetzt freigegeben mit "+vCHG_Max_I.state.toString+" A")
   }
end 

// rule Minuten Task
// wenn Zeit = Startzeit und TimerMode=an, dann starten
// kwh charged updaten
rule "Rule_Updates_1min"
when 
  Time cron "0 * * * * ?"              // checken jede Minute
then
   if (Go_Charge.state==ON) {

	   var int startMinute = (vCHG_StartTime_M.state as DecimalType).intValue
	   var int startStunde = (vCHG_StartTime_H.state as DecimalType).intValue
      var int stopMinute = (vCHG_StopTime_M.state as DecimalType).intValue
	   var int stopStunde = (vCHG_StopTime_H.state as DecimalType).intValue

	   if (    (vCHG_StartTime_en.state==ON) 
           && (startMinute == now.getMinute() ) 
           && (startStunde == now.getHour() ) 
      {
         WB_R261_Set_Max_I.sendCommand(60)            // Beispiel 6A no Timer, start now
         logInfo("Rule_Updates_1min: ", "Startzeit erreicht: Laden gestartet")
      }

      if (    (vCHG_StopTime_en.state==ON) 
           && (stopMinute == now.getMinute() ) 
           && (stopStunde == now.getHour() ) 
      {
         WB_R261_Set_Max_I.sendCommand(0)             // Laden unterbrechen durch Senden von 0
         logInfo("Rule_Updates_1min: ", "Stopzeit erreicht: Laden beendet")
      }

      // Update kWH erreicht
      // {
      //    WB_R261_Set_Max_I.sendCommand(0)             // Laden unterbrechen durch Senden von 0
      //    logInfo("Rule_Updates_1min: ", "Energy Limit erreicht: Laden beendet")
      // }
   } 
end



rule "Rule_Stop_Charging"
when
   Item Go_Charge received command OFF
then 
   WB_R261_Set_Max_I.sendCommand(0)             // Laden unterbrechen durch Senden von 0
   logInfo("Rule_Stop_Charging: ", "Laden beendet")
end 



// ------------------------------
// *** Modbus error handling
// ------------------------------


rule "Rule_WB_Poller1_Offline"
when
    Thing "modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg4to18" changed
then
	var Tstatus = getThingStatusInfo("modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg4to18").getStatus()
    if ( (Tstatus.toString == "OFFLINE") || (Tstatus.toString == "UNINITIALIZED" )) 
	{
     logInfo("Rule_WB_Poller1_Offline: ", "ALARM! Poller1 Offline")
	}
end
	 
// modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg100to101
