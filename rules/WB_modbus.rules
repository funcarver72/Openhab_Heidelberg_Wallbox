// Rule File  OpenHAB V3.xx    for Wallbox

var Number ChargingDurationStart     //  save start point in time in millis


rule "Rule_WB_Init"
when
	System started
   or Item SysInit received command ON
then
	logInfo("Init rule: ", "Rule Init Started")

   // Wallbox Init
   // WB_R261_Set_Max_I.sendCommand(60)      // init to min setting, 60 = 6A
   // Thread::sleep(100)

   // WB_R262_Set_FS_I.sendCommand(60)       // init to min setting, 60 = 6A
   // Thread::sleep(100)

   // WB_R259w_RemoveLock.sendCommand(1)      // init to unlocked
   // Thread::sleep(100)

   // WB_R258w_Standby.sendCommand(4)         // init to  No Standby !!
   // Thread::sleep(100)

   // User Interface Init
   if (vCHG_EnergyTarget_en.state==NULL)  vCHG_EnergyTarget_en.sendCommand(OFF)
   if (vCHG_EnergyLimit.state==NULL)      vCHG_EnergyLimit.sendCommand(50)
   if (vCHG_PowerTarget_en.state==NULL)   vCHG_PowerTarget_en.sendCommand(0)
   if (vCHG_PowerLimit.state==NULL)       vCHG_PowerLimit.sendCommand(6)

   // if (vCHG_StartTime_en.state==NULL)     vCHG_StartTime_en.sendCommand(OFF)
   if (vCHG_StartTime_H.state==NULL)      vCHG_StartTime_H.sendCommand(18)
   if (vCHG_StartTime_M.state==NULL)      vCHG_StartTime_M.sendCommand(0)

   // if (vCHG_StopTime_en.state==NULL)      vCHG_StopTime_en.sendCommand(OFF)
   if (vCHG_StopTime_H.state==NULL)       vCHG_StopTime_H.sendCommand(6)
   if (vCHG_StopTime_M.state==NULL)       vCHG_StopTime_M.sendCommand(0)

   // Initialisieren der Strings
   vCHG_StartTime_en.sendCommand(ON)
   vCHG_StopTime_en.sendCommand(ON)  
   vCHG_StartTime_en.sendCommand(OFF)
   vCHG_StopTime_en.sendCommand(OFF)

   Go_Charge.sendCommand(OFF)
end 


// ------------------------------
// ***   Charging Control     ***
// ------------------------------

//  Formel zur Ermittlung des Max. Ladestroms
//  Ladestrom(neu) = Energieproduktion  -  (HausVerbrauch + Ladestrom(alt) )
//  Dann:  Wenn Ladestrom <= 0 dann Ladestrom = 0

//  Update, alle 5 Minuten (oder besser wenn sich die Zahlen ändern)

// bei 3-phasigem Laden ganz einfach:
//  Laden mit 6A  wenn  der Berechnete Ladestrom >0 ist
// bei 1-phasigem Laden kann man in den Bereich der Regelung kommen.




rule "Rule_Determine_Phases" 
when
   System started
   or Item WB_R010_V_L1 changed
   or Item WB_R010_V_L2 changed 
   or Item WB_R010_V_L3 changed
then 
   if ( (WB_R010_V_L1.state < 50) && (WB_R011_V_L2.state < 50) && (WB_R012_V_L3.state < 50) ) {
      WB_1phase_mode.sendCommand(OFF)
      WB_3phase_mode.sendCommand(OFF)
      // send Mail: Wallbox Ausgeschaltet ?
   } 
   else if ( (WB_R010_V_L1.state > 215) && (WB_R011_V_L2.state < 50) && (WB_R012_V_L3.state < 50) ) {
      WB_1phase_mode.sendCommand(ON)
      WB_3phase_mode.sendCommand(OFF)
   }
   else if ( (WB_R010_V_L1.state > 215) && (WB_R011_V_L2.state > 215) && (WB_R012_V_L3.state > 215) ) {
      WB_1phase_mode.sendCommand(OFF)
      WB_3phase_mode.sendCommand(ON)
   } 
   else {
      WB_1phase_mode.sendCommand(OFF)
      WB_3phase_mode.sendCommand(OFF)
      // send Mail: Wallbox Unbekannter Versorgungszustand
   } 
end


rule "Rule_Determine_CHG_Current"
when 
   System started
or Item vCHG_PowerTarget_en received command
or Item vCHG_PowerLimit received command
then 
  if (vCHG_PowerTarget_en.state==0)
   vCHG_Max_I.sendCommand(160)                  // max Current 16A
  else if (vCHG_PowerTarget_en.state==1)  {     // Selected Power
          
     if (vCHG_PowerLimit.state==2)        vCHG_Max_I.sendCommand(60)     // 29  --> nicht erlaubt.  setze 60   
      else if (vCHG_PowerLimit.state==3)  vCHG_Max_I.sendCommand(60)     //  44 nicht erlaubt. setze 60
      else if (vCHG_PowerLimit.state==4)  vCHG_Max_I.sendCommand(60)   
      else if (vCHG_PowerLimit.state==5)  vCHG_Max_I.sendCommand(73)   
      else if (vCHG_PowerLimit.state==6)  vCHG_Max_I.sendCommand(87)   
      else if (vCHG_PowerLimit.state==7)  vCHG_Max_I.sendCommand(102)   
      else if (vCHG_PowerLimit.state==8)  vCHG_Max_I.sendCommand(116)   
      else if (vCHG_PowerLimit.state==9)  vCHG_Max_I.sendCommand(130)   
      else if (vCHG_PowerLimit.state==10) vCHG_Max_I.sendCommand(145)   
      else logError("Rule_Determine_CHG_Current", "Unknown Selection of PowerLimit")

  }
  else if (vCHG_PowerTarget_en.state==2) {     // PV Überschuss
      vCHG_Max_I.sendCommand(60)     // Minimum for ON as Starting Value. To be Updated periodically
  }
  else logError("Rule_Determine_CHG_Current", "Unknown Selection of PowerTarget_en")

end


// --------------
//  Timers
rule "Rule_CHG_StartTime_Set"
when 
   Item vCHG_StartTime_en received command ON
or Item vCHG_StartTime_H  received update  
or Item vCHG_StartTime_M  received update 
then
 if (vCHG_StartTime_M.state == 0) 
  vCHG_StartTime_S.postUpdate( (vCHG_StartTime_H.state as Number).intValue.toString + ":00"  )
 else
  vCHG_StartTime_S.postUpdate( (vCHG_StartTime_H.state as Number).intValue.toString + ":" + (vCHG_StartTime_M.state as Number).intValue.toString)
end 

rule "Rule_CHG_StopTime_Set"
when 
   Item vCHG_StopTime_en received command ON
or Item vCHG_StopTime_H  received update  
or Item vCHG_StopTime_M  received update 
then
 if (vCHG_StopTime_M.state == 0) 
  vCHG_StopTime_S.postUpdate( (vCHG_StopTime_H.state as Number).intValue.toString + ":00"  )
 else
  vCHG_StopTime_S.postUpdate( (vCHG_StopTime_H.state as Number).intValue.toString + ":" + (vCHG_StopTime_M.state as Number).intValue.toString)
end 


rule "Rule_Format_CHG_Currents"
when
      Item WB_R006_I_L1 received update 
   or Item WB_R007_I_L2 received update
   or Item WB_R008_I_L3 received update
then 
     vWB_Currents_L1L2L3.postUpdate( (WB_R006_I_L1.state as Number).toString + " A / " + (WB_R007_I_L2.state as Number).toString + " A / " + (WB_R008_I_L3.state as Number).toString + " A" )
end


rule "Rule_Format_Supply_Voltages"
when
      Item WB_R010_V_L1 received update 
   or Item WB_R011_V_L2 received update
   or Item WB_R012_V_L3 received update
then 
     vWB_SupplyV_L1L2L3.postUpdate( (WB_R010_V_L1.state as Number).toString + " V / " + (WB_R011_V_L2.state as Number).toString + " V / " + (WB_R012_V_L3.state as Number).toString + " V" )
end


rule "Rule_Start_Charging"
when
   Item Go_Charge received command ON
then 
   vCHG_EnergyCharged.postUpdate(0.0)                                    // Charging Energy Counter 0 setzen
   vCHG_EnergyStart.postUpdate(WB_R015_Energy_PwrOn.state as Number)     // Startwert des EnergyCounters sichern
   
   var String vCurrent = String.format("%.1f", (vCHG_Max_I.state as Number) /10)     // Calculate for Logging

   if (vCHG_StartTime_en.state==OFF)  {
      WB_R261_Set_Max_I.sendCommand(vCHG_Max_I.state as Number)
      ChargingDurationStart = now.toInstant.toEpochMilli
      logInfo("Rule_Start_Charging: ", "Laden jetzt freigegeben mit "+vCurrent+" A")
   }
   else logInfo("Rule_Start_Charging: ", "Laden freigegeben mit "+vCurrent+" A  um " +vCHG_StartTime_S.state+"h")

end 



rule "Rule_Updates_1min"
when 
  Time cron "0 * * * * ?"              // trigger every minute
then
   if (Go_Charge.state==ON) {

	   var int startMinute = (vCHG_StartTime_M.state as DecimalType).intValue
	   var int startStunde = (vCHG_StartTime_H.state as DecimalType).intValue
      var int stopMinute = (vCHG_StopTime_M.state as DecimalType).intValue
	   var int stopStunde = (vCHG_StopTime_H.state as DecimalType).intValue

	   if (    (vCHG_StartTime_en.state==ON) 
           && (startMinute == now.getMinute() ) 
           && (startStunde == now.getHour() ) 
         )
      {
         WB_R261_Set_Max_I.sendCommand(vCHG_Max_I.state as Number)
         ChargingDurationStart = now.toInstant.toEpochMilli
         logInfo("Rule_Updates_1min: ", "Startzeit erreicht: Laden gestartet mit "+vCHG_Max_I.state.toString+"/10 A")
      }  // end Start Time

      if (    (vCHG_StopTime_en.state==ON) 
           && (stopMinute == now.getMinute() ) 
           && (stopStunde == now.getHour() ) 
         )
      {
         logInfo("Rule_Updates_1min: ", "Stopzeit erreicht")
         Go_Charge.sendCommand(OFF)
      } // end Stop Time

      // Update Charged Energy Counter
      var Number E_n_G = (WB_R015_Energy_PwrOn.state as Number) - (vCHG_EnergyStart.state as Number)
      vCHG_EnergyCharged.postUpdate(E_n_G)
 
      // Manage Energy Target
      if (vCHG_EnergyTarget_en.state==ON) 
      { 
        if (vCHG_EnergyCharged.state >= vCHG_EnergyLimit.state ) 
        {
         logInfo("Rule_Updates_1min: ", "Energy Limit reached")
         Go_Charge.sendCommand(OFF)
        }
      }  // End Energy Target

    
      // Manage PV Power left for Charging    to be completed
      var Number vCHG_Max_P_new = (OH2Main_ItemSenec_EnergyProduction.state as Number) - ( (OH2Main_ItemSenec_HouseConsumption.state as Number) + (vCHG_PowerLimit.state as Number) )

      if (vCHG_PowerTarget_en.state==2) {
         // vCHG_Max_I.sendCommand(   )    // to be done 
         logInfo("Rule_Updates_1min: ", "New Power Limit: "+vCHG_Max_P_new.toString()+" W")   // DEBUG !

      } // PV Power Target

   } 
end



rule "Rule_Stop_Charging"
when
   Item Go_Charge received command OFF
then 
   WB_R261_Set_Max_I.sendCommand(0)             // Laden unterbrechen durch Senden von 0
   // Calculate Chg Duration
   val Number CHG_Duration =  now.toInstant.toEpochMilli - ChargingDurationStart  // Differenz in Millisekunden
   val Number CHG_Minutes = (CHG_Duration / 60000).intValue                  // Duration in Minutes
   logInfo("Rule_Stop_Charging: ", "Laden beendet, "+(vCHG_EnergyCharged.state as Number)+" kWh geladen in "+(CHG_Minutes).toString+" min")
end 


// rule "Stop_Charging_byCar"   // to be done
// when
//  Item WB_R005_CH_State changed
// then
// evaluate Car Charging state
// And stop charging if Car fully Charged



// ------------------------------
// *** Modbus error handling
// ------------------------------


rule "Rule_WB_Poller1_Offline"
when
    Thing "modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg4to18" changed
then
	var Tstatus = getThingStatusInfo("modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg4to18").getStatus()
    if ( (Tstatus.toString == "OFFLINE") || (Tstatus.toString == "UNINITIALIZED" )) 
	{
     logInfo("Rule_WB_Poller1_Offline: ", "ALARM! Poller1 Offline")
	}
end
	 
// modbus:poller:Modbus_RTU_Slave1_WB:WB_Poll_Reg100to101

